# Architecture Explanation: Models and Migrations in Infrastructure Layer

## Why Models Are in the Infrastructure Layer

In **Layered Architecture**, each layer has a specific responsibility:

### Layer Responsibilities

1. **Domain Layer** (`domain/`)
   - Contains **pure business logic** and entities
   - **Framework-agnostic** - no Django, Flask, or any framework dependencies
   - Example: `Ticket` entity is a pure Python dataclass

2. **Service Layer** (`service/`)
   - Orchestrates business workflows
   - **Framework-agnostic** - uses domain entities and repository interfaces
   - Example: `TicketService` coordinates classification and persistence

3. **Infrastructure Layer** (`infrastructure/`)
   - Contains **framework-specific implementations** of business operations
   - **HOW we implement** business operations (persist data, call APIs)
   - Database access, external services, file I/O
   - **Django-specific code lives here**
   - Example: `TicketModel` inherits from `django.db.models.Model`
   - Example: `DjangoTicketRepository` uses Django ORM to save tickets

4. **Entry Layer** (`entrypoints/web/`)
   - Contains **framework-specific entry points** for receiving requests
   - **HOW we receive** requests/commands (HTTP, CLI, Queue)
   - Framework entry points (Django-Ninja API endpoints, CLI commands)
   - Converts HTTP requests to service calls
   - Example: `@router.post("/tickets/")` receives HTTP POST requests

### Why Django Models Are Infrastructure

Django models (`TicketModel`) are **framework-specific** because they:
- Inherit from `django.db.models.Model`
- Use Django ORM features (fields, Meta options)
- Are tied to Django's database abstraction

If we wanted to switch from Django to Flask or FastAPI, we would:
- ✅ Keep the **Domain Layer** unchanged (pure Python)
- ✅ Keep the **Service Layer** unchanged (uses interfaces)
- ❌ Replace the **Infrastructure Layer** (new ORM, new models)
- ❌ Replace the **Entry Layer** (new web framework)

This separation allows us to:
- **Test business logic** without Django
- **Swap databases** (SQLite → PostgreSQL) without changing business logic
- **Swap frameworks** (Django → FastAPI) without changing business logic

## How Migrations Work

### What Are Migrations?

Django migrations are Python files that describe database schema changes. They:
- Track changes to models over time
- Can be version controlled
- Can be applied/rolled back

### How to Generate Migrations

1. **Navigate to the project root** (where `manage.py` is located):
   ```bash
   cd /home/shahriyarrzayev/REPOS/Others/ai-customer-ticket-manager
   ```

2. **Generate migrations** for the `infrastructure.models` app:
   ```bash
   python src/pyticket/entrypoints/web/manage.py makemigrations infrastructure.models
   ```
   
   Or generate for all apps:
   ```bash
   python src/pyticket/entrypoints/web/manage.py makemigrations
   ```

3. **Apply migrations** to create database tables:
   ```bash
   python src/pyticket/entrypoints/web/manage.py migrate
   ```

### Migration File Location

Migrations are stored in:
```
src/pyticket/infrastructure/models/migrations/
├── __init__.py
└── 0001_initial.py  (generated by Django)
```

### Why Migrations Are in Infrastructure

Migrations are **Django-specific** because they:
- Use Django's migration framework
- Reference Django models
- Are executed by Django's migration system

They belong in the infrastructure layer alongside the models they modify.

## Architecture Flow

```
┌─────────────────────────────────────────┐
│   Entry Layer (Django-Ninja API)        │
│   - HTTP endpoints                      │
│   - Request/Response schemas            │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│   Service Layer (Business Logic)        │
│   - TicketService                       │
│   - ClassificationService               │
│   - Uses: Domain entities + Interfaces  │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│   Domain Layer (Pure Business Logic)    │
│   - Ticket entity (dataclass)           │
│   - Business rules                      │
│   - NO framework dependencies           │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│   Infrastructure Layer (Framework Code) │
│   - TicketModel (Django ORM)            │
│   - DjangoTicketRepository              │
│   - AI Provider implementations         │
│   - Migrations (Django-specific)        │
└─────────────────────────────────────────┘
```

## Example: Testing Without Django

Because of this separation, we can test business logic without Django:

```python
# tests/domain/test_entities.py
# ✅ No Django imports needed!
from pyticket.domain.tickets.entities import Ticket, Category, Priority

def test_ticket_creation():
    ticket = Ticket(title="Test", description="Test")
    assert ticket.title == "Test"
    # Pure Python - no Django required
```

```python
# tests/infrastructure/test_repository.py
# ⚠️ Django needed here (testing infrastructure)
import pytest
from pyticket.infrastructure.repositories.django_ticket_repository import DjangoTicketRepository

@pytest.mark.django_db
def test_save_ticket():
    # Django-specific test
    repository = DjangoTicketRepository()
    # ...
```

## Summary

- **Models in Infrastructure**: Django models are framework-specific code
- **Domain Entities Separate**: Pure Python entities live in domain layer
- **Migrations in Infrastructure**: Django-specific migration files
- **Separation of Concerns**: Business logic independent of framework
- **Testability**: Domain/service layers testable without Django

This architecture makes the codebase:
- ✅ **Maintainable**: Clear boundaries between layers
- ✅ **Testable**: Each layer can be tested independently
- ✅ **Flexible**: Can swap frameworks/databases without rewriting business logic
- ✅ **Scalable**: Easy to add new features without breaking existing code

